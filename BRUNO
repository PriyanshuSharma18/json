#!/usr/bin/env python3
"""
Azure Event Hubs â€“ Weather Email â†’ Event Pipeline

Behavior based on ENV:

  ENV=global
    - Extract JSON advisory from each relevant email
    - DO NOT create/store JSON files
    - Send each advisory as an Event to Azure Event Hub

  ENV=local
    - Extract JSON advisory from each relevant email
    - Create & store JSON file per email in OUTPUT_DIR
    - Send each advisory as an Event to Azure Event Hub

Usage:
  python src/send_events.py

Required env (.env or environment):
  EVENTHUB_CONNECTION_STRING
  EVENTHUB_NAME
  EVENTHUB_NAMESPACE     (optional, informational)
  ENV=local | global
"""

import asyncio
import json
import os
from datetime import datetime
from typing import Dict, Optional, List

from azure.eventhub import EventData
from azure.eventhub.aio import EventHubProducerClient

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#  IMPORT YOUR EMAIL-EXTRACTOR LOGIC HERE
#  Replace `weather_email_processor` with the actual filename (without .py)
#  This module should contain:
#    - get_all_messages(page_size: int = 50, max_pages: int = None) -> list[dict]
#    - process_single_email(message: dict) -> Optional[dict]   (returns weather_advisory)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
from weather_email_processor import (
    get_all_messages,
    process_single_email,
)
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# ------------------ Utilities ------------------

def load_env(path: str = ".env") -> None:
    """Minimal .env loader (no external dependency).
    Lines in KEY=VALUE format (quotes optional). Ignores comments/blank lines.
    """
    if not os.path.exists(path):
        return
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if '=' not in line:
                continue
            key, value = line.split('=', 1)
            key = key.strip()
            value = value.strip().strip('"').strip("'")
            # Do not override an already-set env var
            os.environ.setdefault(key, value)


def sanitize_filename(filename: str) -> str:
    """Remove characters that are invalid in file names on Windows/Linux."""
    import re
    return re.sub(r'[<>:"/\\|?*]', '_', filename)


# Load .env early
load_env()

# ------------------ Configuration ------------------

ENV = os.environ.get("ENV", "").lower()  # "local" or "global"
IS_LOCAL_ENV = (ENV == "local")

EVENTHUB_NAMESPACE = os.environ.get("EVENTHUB_NAMESPACE")
EVENTHUB_NAME = os.environ.get("EVENTHUB_NAME")
CONNECTION_STRING = os.environ.get("EVENTHUB_CONNECTION_STRING")

# Where to store JSON files when ENV=local
OUTPUT_DIR = os.environ.get("OUTPUT_DIR", "email_extracts")

if IS_LOCAL_ENV and not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR, exist_ok=True)


# Optional older file-based path (still here if you want to reuse it)
WEATHER_DATA_FILE = os.environ.get("WEATHER_DATA_FILE", "weather_advisories.json")


# ------------------ Optional: file-based reader (legacy) ------------------

def read_weather_advisories(file_path: Optional[str] = None) -> Dict:
    """
    (Legacy / optional) Read weather advisory data from a single JSON file.

    Not used in the emailâ†’Event pipeline below, but kept if you
    still want to send from a static JSON file sometimes.
    """
    if file_path is None:
        file_path = WEATHER_DATA_FILE

    if not os.path.exists(file_path):
        raise FileNotFoundError(
            f"Weather advisories file not found: {file_path}\n"
            f"Please run your data creator script first to generate the data file."
        )

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        if not isinstance(data, dict):
            raise ValueError(f"Expected dictionary in {file_path}, got {type(data)}")

        print(f"âœ“ Loaded advisory JSON from {file_path}")
        return data

    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in {file_path}: {e}")
    except Exception as e:
        raise ValueError(f"Error reading {file_path}: {e}")


# ------------------ Sample test event factory (unchanged) ------------------

def create_sample_weather_event(event_id: int) -> Dict:
    """Create a sample weather event payload (for manual testing)."""
    return {
        "event_id": event_id,
        "timestamp": datetime.utcnow().isoformat(),
        "location": {
            "latitude": 40.7128 + (event_id * 0.001),
            "longitude": -74.0060 + (event_id * 0.001),
            "city": f"Testcity{event_id}",
            "country": "US",
        },
        "weather": {
            "temperature": 20 + (event_id % 15),
            "humidity": 60 + (event_id % 30),
            "pressure": 1013 + (event_id % 10),
            "wind_speed": 10 + (event_id % 20),
            "wind_direction": (event_id * 45) % 360,
            "conditions": ["sunny", "cloudy", "rainy", "stormy"][event_id % 4],
        },
        "source": "test-script",
        "version": "1.0",
    }


# ------------------ EventHub Sender ------------------

async def send_single_event(event_data: Dict) -> None:
    """Send a single custom event (dict) to Event Hub as JSON."""
    if not CONNECTION_STRING:
        raise ValueError(
            "EVENTHUB_CONNECTION_STRING environment variable not set.\n"
            "Set it in .env or export it in your shell."
        )

    if not EVENTHUB_NAME:
        raise ValueError("EVENTHUB_NAME environment variable not set.")

    print(f"â†’ Sending single event to EventHub: {EVENTHUB_NAME}")

    producer = EventHubProducerClient.from_connection_string(
        conn_str=CONNECTION_STRING,
        eventhub_name=EVENTHUB_NAME,
    )

    try:
        async with producer:
            event_data_batch = await producer.create_batch()
            event_json = json.dumps(event_data)
            event_data_batch.add(EventData(event_json))
            await producer.send_batch(event_data_batch)
            print("âœ“ Event sent successfully")
    except Exception as e:
        print(f"âœ— Error sending event: {e}")
        raise
    finally:
        await producer.close()


async def send_events_batch(num_events: int = 10) -> None:
    """(Optional) Send a batch of dummy test events to Event Hub."""
    if not CONNECTION_STRING:
        raise ValueError(
            "EVENTHUB_CONNECTION_STRING environment variable not set.\n"
            "Set it in .env or export it in your shell."
        )

    if not EVENTHUB_NAME:
        raise ValueError("EVENTHUB_NAME environment variable not set.")

    print(f"Connecting to EventHub: {EVENTHUB_NAME}")
    print(f"Namespace: {EVENTHUB_NAMESPACE}")
    print(f"Preparing to send {num_events} test events...")

    producer = EventHubProducerClient.from_connection_string(
        conn_str=CONNECTION_STRING,
        eventhub_name=EVENTHUB_NAME,
    )

    try:
        async with producer:
            event_data_batch = await producer.create_batch()
            events_sent = 0

            for i in range(num_events):
                event_payload = create_sample_weather_event(i + 1)
                event_json = json.dumps(event_payload)

                try:
                    event_data_batch.add(EventData(event_json))
                    events_sent += 1
                    print(f"âœ“ Added test event {i + 1} to batch: {event_payload['location']['city']}")
                except ValueError:
                    print(f"Batch full. Sending {events_sent} events...")
                    await producer.send_batch(event_data_batch)
                    print("âœ“ Batch sent successfully!")

                    event_data_batch = await producer.create_batch()
                    event_data_batch.add(EventData(event_json))
                    events_sent = 1

            if events_sent > 0:
                print(f"Sending final batch of {events_sent} events...")
                await producer.send_batch(event_data_batch)
                print("âœ“ Final batch sent successfully!")

        print("=" * 60)
        print(f"âœ“ Successfully sent {num_events} test events to EventHub")

    except Exception as e:
        print(f"âœ— Error sending test events: {e}")
        raise
    finally:
        await producer.close()


# ------------------ EMAIL â†’ JSON â†’ EVENT PIPELINE ------------------

def collect_weather_advisories_from_email() -> List[Dict]:
    """
    Use your email-extractor script to:
      - Fetch emails via Graph
      - Extract per-email advisory JSON (station list, etc.)
      - Optionally create & store JSON files (only in ENV=local)
    Returns:
      List of advisory dicts (one per email where extraction succeeded)
    """
    print("=" * 60)
    print("ðŸ“¥ Collecting Weather Advisories from Emails (via Graph)")
    print(f"Environment mode: {ENV} (IS_LOCAL_ENV={IS_LOCAL_ENV})")
    print("=" * 60)

    all_messages = get_all_messages(page_size=50)
    total_emails = len(all_messages)

    advisories: List[Dict] = []

    print(f"Total emails fetched from Graph: {total_emails}")

    for idx, message in enumerate(all_messages):
        subject = message.get("subject", "No Subject")
        short_subject = subject[:80]
        print(f"\nProcessing email {idx + 1}/{total_emails}: {short_subject!r}")

        weather_advisory = process_single_email(message)

        if not weather_advisory:
            print("   â†³ Skipped (no valid advisory extracted).")
            continue

        # If ENV=local â†’ save JSON file per email
        if IS_LOCAL_ENV:
            received_dt = message.get("receivedDateTime", "")[:10].replace("-", "_")
            subject_clean = sanitize_filename(subject[:30] or "No_Subject")
            filename = f"{idx + 1:03d}_{received_dt}_{subject_clean}.json"
            filepath = os.path.join(OUTPUT_DIR, filename)

            try:
                with open(filepath, "w", encoding="utf-8") as f:
                    json.dump(weather_advisory, f, indent=2, ensure_ascii=False)
                station_count = len(weather_advisory.get("stations", []))
                print(f"   âœ“ Saved advisory JSON ({station_count} station(s)) to {filepath}")
            except Exception as e:
                print(f"   âœ— Error saving JSON file {filepath}: {e}")

        else:
            print("   (global ENV) Not writing JSON file, only sending to EventHub.")

        advisories.append(weather_advisory)

    print("\nSummary:")
    print(f"  Emails scanned: {total_emails}")
    print(f"  Advisories extracted: {len(advisories)}")
    if IS_LOCAL_ENV:
        print(f"  JSON files directory: {OUTPUT_DIR}")

    return advisories


async def send_all_advisories_from_email() -> None:
    """
    High-level pipeline:
      1) Extract advisories from email body (using your existing script)
      2) If ENV=local â†’ also save JSON files
      3) Send each advisory as an Event to Azure Event Hub
    """
    advisories = collect_weather_advisories_from_email()

    if not advisories:
        print("No advisories to send. Exiting.")
        return

    print("\n" + "=" * 60)
    print(f"ðŸš€ Sending {len(advisories)} advisory event(s) to EventHub: {EVENTHUB_NAME}")
    print("=" * 60)

    for i, advisory in enumerate(advisories, start=1):
        print(f"\nEvent {i}/{len(advisories)}:")
        await send_single_event(advisory)

    print("\nâœ… All advisory events sent successfully.")


# ------------------ Entrypoint ------------------

def main() -> None:
    import sys

    print("=" * 60)
    print("Azure EventHub Weather Advisory Sender (Email â†’ Events)")
    print("=" * 60)
    print(f"ENV = {ENV}")
    print(f"EVENTHUB_NAME = {EVENTHUB_NAME}")
    print(f"EVENTHUB_NAMESPACE = {EVENTHUB_NAMESPACE}")
    print("=" * 60)

    # If you still want a CLI flag to send dummy test events:
    # python send_events.py test 5
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        num_events = 5
        if len(sys.argv) > 2:
            try:
                num_events = int(sys.argv[2])
            except ValueError:
                print(f"Invalid num_events: {sys.argv[2]} (using default 5)")
        try:
            asyncio.run(send_events_batch(num_events))
        except KeyboardInterrupt:
            print("Interrupted by user")
        except Exception as e:
            print(f"Failed to send test events: {e}")
            sys.exit(1)
        return

    # Default behavior: email â†’ JSON â†’ EventHub (with ENV-based behavior)
    try:
        asyncio.run(send_all_advisories_from_email())
    except KeyboardInterrupt:
        print("Interrupted by user")
    except Exception as e:
        print(f"Failed to process/send advisory events: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
